import { z } from 'zod';

/**
 * CSS selector for form field mapping
 */
export interface Selector {
  /** CSS selector string */
  selector: string;
  /** XPath selector (alternative to CSS) */
  xpath?: string;
  /** Priority for this selector (higher = preferred) */
  priority?: number;
}

/**
 * Field mapping for a specific site
 */
export interface FieldMapping {
  /** Canonical field name */
  canonical: string;
  /** List of selectors to try */
  selectors: Selector[];
  /** Whether this mapping is auto-generated */
  autoGenerated?: boolean;
  /** Last updated timestamp */
  lastUpdated?: number;
}

/**
 * Site-specific mapping profile
 */
export interface MappingProfile {
  /** Profile version */
  version: number;
  /** Site URL pattern */
  site: string;
  /** Field mappings */
  selectors: Record<string, string[]>;
  /** Created timestamp */
  created: number;
  /** Last updated timestamp */
  updated: number;
  /** Profile description */
  description?: string;
}

/**
 * Form field information collected from DOM
 */
export interface FormField {
  /** Element type (input, select, textarea) */
  type: string;
  /** CSS selector */
  selector: string;
  /** XPath selector */
  xpath: string;
  /** Field name attribute */
  name?: string;
  /** Field id attribute */
  id?: string;
  /** Field class names */
  className?: string;
  /** Placeholder text */
  placeholder?: string;
  /** Associated label text */
  label?: string;
  /** Aria label */
  ariaLabel?: string;
  /** Input type (text, email, etc.) */
  inputType?: string;
  /** Whether field is required */
  required?: boolean;
  /** Whether field is disabled */
  disabled?: boolean;
  /** Current value */
  value?: string;
  /** Bounding rectangle */
  rect: DOMRect;
}

/**
 * Matching result between extracted field and DOM field
 */
export interface FieldMatch {
  /** Extracted field */
  field: string;
  /** DOM field */
  domField: FormField;
  /** Similarity score (0-1) */
  score: number;
  /** Match confidence level */
  confidence: 'high' | 'medium' | 'low';
  /** Match method used */
  method: 'selector' | 'semantic' | 'fuzzy';
}

/**
 * Fill operation result
 */
export interface FillResult {
  /** Field that was filled */
  field: string;
  /** DOM selector used */
  selector: string;
  /** Value that was filled */
  value: string;
  /** Whether the fill was successful */
  success: boolean;
  /** Error message if failed */
  error?: string;
  /** Confidence score */
  confidence: number;
  /** Source candidate used */
  source: {
    page: number;
    bbox: [number, number, number, number];
    text: string;
  };
}

/**
 * Zod schemas for validation
 */
export const SelectorSchema = z.object({
  selector: z.string(),
  xpath: z.string().optional(),
  priority: z.number().optional()
});

export const FieldMappingSchema = z.object({
  canonical: z.string(),
  selectors: z.array(SelectorSchema),
  autoGenerated: z.boolean().optional(),
  lastUpdated: z.number().optional()
});

export const MappingProfileSchema = z.object({
  version: z.number(),
  site: z.string(),
  selectors: z.record(z.string(), z.array(z.string())),
  created: z.number(),
  updated: z.number(),
  description: z.string().optional()
});

export const FormFieldSchema = z.object({
  type: z.string(),
  selector: z.string(),
  xpath: z.string(),
  name: z.string().optional(),
  id: z.string().optional(),
  className: z.string().optional(),
  placeholder: z.string().optional(),
  label: z.string().optional(),
  ariaLabel: z.string().optional(),
  inputType: z.string().optional(),
  required: z.boolean().optional(),
  disabled: z.boolean().optional(),
  value: z.string().optional(),
  rect: z.object({
    x: z.number(),
    y: z.number(),
    width: z.number(),
    height: z.number(),
    top: z.number(),
    right: z.number(),
    bottom: z.number(),
    left: z.number()
  })
});

export const FieldMatchSchema = z.object({
  field: z.string(),
  domField: FormFieldSchema,
  score: z.number().min(0).max(1),
  confidence: z.enum(['high', 'medium', 'low']),
  method: z.enum(['selector', 'semantic', 'fuzzy'])
});

export const FillResultSchema = z.object({
  field: z.string(),
  selector: z.string(),
  value: z.string(),
  success: z.boolean(),
  error: z.string().optional(),
  confidence: z.number().min(0).max(1),
  source: z.object({
    page: z.number(),
    bbox: z.tuple([z.number(), z.number(), z.number(), z.number()]),
    text: z.string()
  })
});